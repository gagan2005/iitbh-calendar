/* src\App.svelte generated by Svelte v3.31.0 */
import {
	SvelteComponent,
	add_flush_callback,
	append,
	bind,
	binding_callbacks,
	create_component,
	destroy_component,
	destroy_each,
	detach,
	element,
	empty,
	init,
	insert,
	listen,
	mount_component,
	noop,
	run_all,
	safe_not_equal,
	set_data,
	space,
	text,
	transition_in,
	transition_out
} from "../web_modules/svelte/internal.js";

import AutoComplete from "../web_modules/simple-svelte-autocomplete.js";
import courseData from "./data/courses.json.proxy.js";
import { makeCalendar } from "./createCalendar.js";

function get_each_context(ctx, list, i) {
	const child_ctx = ctx.slice();
	child_ctx[9] = list[i];
	child_ctx[11] = i;
	return child_ctx;
}

// (56:2) {#each selectedCourses as course, idx}
function create_each_block(ctx) {
	let li;
	let t0_value = /*course*/ ctx[9].label + "";
	let t0;
	let t1;
	let button;
	let t3;
	let mounted;
	let dispose;

	function click_handler() {
		return /*click_handler*/ ctx[8](/*idx*/ ctx[11]);
	}

	return {
		c() {
			li = element("li");
			t0 = text(t0_value);
			t1 = space();
			button = element("button");
			button.textContent = "delete";
			t3 = space();
		},
		m(target, anchor) {
			insert(target, li, anchor);
			append(li, t0);
			append(li, t1);
			append(li, button);
			append(li, t3);

			if (!mounted) {
				dispose = listen(button, "click", click_handler);
				mounted = true;
			}
		},
		p(new_ctx, dirty) {
			ctx = new_ctx;
			if (dirty & /*selectedCourses*/ 2 && t0_value !== (t0_value = /*course*/ ctx[9].label + "")) set_data(t0, t0_value);
		},
		d(detaching) {
			if (detaching) detach(li);
			mounted = false;
			dispose();
		}
	};
}

// (66:0) {#if selectedCourses.length > 0}
function create_if_block(ctx) {
	let button;
	let mounted;
	let dispose;

	return {
		c() {
			button = element("button");
			button.textContent = "Download calendar";
		},
		m(target, anchor) {
			insert(target, button, anchor);

			if (!mounted) {
				dispose = listen(button, "click", /*downloadCalendar*/ ctx[6]);
				mounted = true;
			}
		},
		p: noop,
		d(detaching) {
			if (detaching) detach(button);
			mounted = false;
			dispose();
		}
	};
}

function create_fragment(ctx) {
	let h1;
	let t1;
	let autocomplete;
	let updating_selectedItem;
	let t2;
	let button0;
	let t3;
	let button0_disabled_value;
	let t4;
	let ul;
	let t5;
	let button1;
	let t7;
	let if_block_anchor;
	let current;
	let mounted;
	let dispose;

	function autocomplete_selectedItem_binding(value) {
		/*autocomplete_selectedItem_binding*/ ctx[7].call(null, value);
	}

	let autocomplete_props = {
		items: /*courses*/ ctx[2],
		labelFieldName: "label"
	};

	if (/*selectedCourse*/ ctx[0] !== void 0) {
		autocomplete_props.selectedItem = /*selectedCourse*/ ctx[0];
	}

	autocomplete = new AutoComplete({ props: autocomplete_props });
	binding_callbacks.push(() => bind(autocomplete, "selectedItem", autocomplete_selectedItem_binding));
	let each_value = /*selectedCourses*/ ctx[1];
	let each_blocks = [];

	for (let i = 0; i < each_value.length; i += 1) {
		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
	}

	let if_block = /*selectedCourses*/ ctx[1].length > 0 && create_if_block(ctx);

	return {
		c() {
			h1 = element("h1");
			h1.textContent = "Calendar Generator";
			t1 = space();
			create_component(autocomplete.$$.fragment);
			t2 = space();
			button0 = element("button");
			t3 = text("Add");
			t4 = space();
			ul = element("ul");

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].c();
			}

			t5 = space();
			button1 = element("button");
			button1.textContent = "reset";
			t7 = space();
			if (if_block) if_block.c();
			if_block_anchor = empty();
			button0.disabled = button0_disabled_value = !/*selectedCourse*/ ctx[0];
		},
		m(target, anchor) {
			insert(target, h1, anchor);
			insert(target, t1, anchor);
			mount_component(autocomplete, target, anchor);
			insert(target, t2, anchor);
			insert(target, button0, anchor);
			append(button0, t3);
			insert(target, t4, anchor);
			insert(target, ul, anchor);

			for (let i = 0; i < each_blocks.length; i += 1) {
				each_blocks[i].m(ul, null);
			}

			insert(target, t5, anchor);
			insert(target, button1, anchor);
			insert(target, t7, anchor);
			if (if_block) if_block.m(target, anchor);
			insert(target, if_block_anchor, anchor);
			current = true;

			if (!mounted) {
				dispose = [
					listen(button0, "click", /*addCourse*/ ctx[3]),
					listen(button1, "click", /*reset*/ ctx[5])
				];

				mounted = true;
			}
		},
		p(ctx, [dirty]) {
			const autocomplete_changes = {};

			if (!updating_selectedItem && dirty & /*selectedCourse*/ 1) {
				updating_selectedItem = true;
				autocomplete_changes.selectedItem = /*selectedCourse*/ ctx[0];
				add_flush_callback(() => updating_selectedItem = false);
			}

			autocomplete.$set(autocomplete_changes);

			if (!current || dirty & /*selectedCourse*/ 1 && button0_disabled_value !== (button0_disabled_value = !/*selectedCourse*/ ctx[0])) {
				button0.disabled = button0_disabled_value;
			}

			if (dirty & /*deleteCourse, selectedCourses*/ 18) {
				each_value = /*selectedCourses*/ ctx[1];
				let i;

				for (i = 0; i < each_value.length; i += 1) {
					const child_ctx = get_each_context(ctx, each_value, i);

					if (each_blocks[i]) {
						each_blocks[i].p(child_ctx, dirty);
					} else {
						each_blocks[i] = create_each_block(child_ctx);
						each_blocks[i].c();
						each_blocks[i].m(ul, null);
					}
				}

				for (; i < each_blocks.length; i += 1) {
					each_blocks[i].d(1);
				}

				each_blocks.length = each_value.length;
			}

			if (/*selectedCourses*/ ctx[1].length > 0) {
				if (if_block) {
					if_block.p(ctx, dirty);
				} else {
					if_block = create_if_block(ctx);
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			} else if (if_block) {
				if_block.d(1);
				if_block = null;
			}
		},
		i(local) {
			if (current) return;
			transition_in(autocomplete.$$.fragment, local);
			current = true;
		},
		o(local) {
			transition_out(autocomplete.$$.fragment, local);
			current = false;
		},
		d(detaching) {
			if (detaching) detach(h1);
			if (detaching) detach(t1);
			destroy_component(autocomplete, detaching);
			if (detaching) detach(t2);
			if (detaching) detach(button0);
			if (detaching) detach(t4);
			if (detaching) detach(ul);
			destroy_each(each_blocks, detaching);
			if (detaching) detach(t5);
			if (detaching) detach(button1);
			if (detaching) detach(t7);
			if (if_block) if_block.d(detaching);
			if (detaching) detach(if_block_anchor);
			mounted = false;
			run_all(dispose);
		}
	};
}

function instance($$self, $$props, $$invalidate) {
	const courses = courseData.filter(course => !["NA", "TBA"].includes(course.lecture)).map(course => ({
		...course,
		label: `${course.code} ${course.name}`
	}));

	let selectedCourse;
	let selectedCourses = [];

	function addCourse() {
		$$invalidate(1, selectedCourses = [...selectedCourses, selectedCourse]);
		$$invalidate(0, selectedCourse = "");
	}

	function deleteCourse(idx) {
		$$invalidate(1, selectedCourses = selectedCourses.filter((_, i) => i !== idx));
	}

	function reset() {
		$$invalidate(0, selectedCourse = "");
		$$invalidate(1, selectedCourses = []);
	}

	function downloadCalendar() {
		const text = makeCalendar(selectedCourses);
		const fileName = "course-calendar.ics", fileType = "text/calendar";
		const blob = new Blob([text], { type: fileType });
		const a = document.createElement("a");
		a.download = fileName;
		a.href = URL.createObjectURL(blob);
		a.dataset.downloadurl = [fileType, a.download, a.href].join(":");
		a.style.display = "none";
		a.click();

		setTimeout(
			function () {
				URL.revokeObjectURL(a.href);
			},
			10000
		);
	}

	function autocomplete_selectedItem_binding(value) {
		selectedCourse = value;
		$$invalidate(0, selectedCourse);
	}

	const click_handler = idx => deleteCourse(idx);

	return [
		selectedCourse,
		selectedCourses,
		courses,
		addCourse,
		deleteCourse,
		reset,
		downloadCalendar,
		autocomplete_selectedItem_binding,
		click_handler
	];
}

class App extends SvelteComponent {
	constructor(options) {
		super();
		init(this, options, instance, create_fragment, safe_not_equal, {});
	}
}

export default App;